syntax = "proto3";

package slsa.v1;

import "google/protobuf/struct.proto";

// NOTE: We use lowerCamelCase for field names because that is how the JSON
// fields are named. The proto style guide advises use of snake_case in the
// .proto file but lowerCamelCase in JSON, but we believe that is confusing for
// readers (since we always serialize to JSON). It also makes it harder to
// reference other fields in comments since there are two ways to reference a
// field.

message Provenance {
  // The set of top-level inputs to the build. This SHOULD contain all the
  // information necessary and sufficient to:
  //
  // 1.  Run the build, provided understanding of the build type and access to
  //     all referenced input artifacts and dependencies.
  // 2.  Verify that the build was as expected.
  //
  // The build system should be designed to minimize the amount of information
  // necessary here, in order to reduce fragility and ease verification.
  // Consumers MUST have an expectation of what "good" looks like; the more
  // information that they must check, the harder that task becomes.
  //
  // Guidelines:
  //
  // -   Maximize the amount of information that is implicit from the meaning of
  //     `type`. In particular, any value that is boilerplate and the same for
  //     every build SHOULD be implicit.
  //
  // -   Avoid parameters by moving configuration to input artifacts whenever
  //     possible. For example, instead of passing in compiler flags via a
  //     parameter, require them to live next to the source code or build
  //     configuration.
  //
  // -   If possible, architect the build system to use this definition as its
  //     sole top-level input, in order to guarantee that the information is
  //     sufficient to run the build.
  //
  // -   Environment variables and artifacts that are not user controlled SHOULD
  //     be part of the `runDetails`, not here. For example, in GitHub Actions,
  //     a user can select which VM image but only from a set of pre-defined
  //     options; that enumeration may go here (though in practice it is part of
  //     the input artifact so it would not be recorded in the provenance) while
  //     the resolved VM version would go in `runDetails`.
  //
  // The accuracy and completeness of this information is implied by
  // `runDetails.builder.id`.
  BuildDefinition buildDefinition = 1;

  // Details about a specific execution of the build definition. Values here
  // MUST NOT be user controlled.
  RunDetails runDetails = 2;
}

message BuildDefinition {
  // URI indicating how to interpret and act upon this message.
  string type = 1 [(subclass) = TypeURI];

  // The top-level, independent input artifacts to the build. In most cases,
  // this is a singular "source" to be built. The key is the name and the value
  // is an Artifact. The interpretation of the key depends on `type`.
  //
  // Conventional names:
  //
  // -   `source`: The primary input to the build. This name SHOULD be used if
  //     there is only one possible input.
  // -   `config`: The build configuration, if independent from `source`.
  // -   `buildImage`: The container or VM image on which the build occurred, if
  //     not specified in `config`.
  //
  // In some cases, the build configuration is evaluated client-side and sent
  // over the wire, such that the build system cannot determine its origin. In
  // those cases, the build system SHOULD serialize the configuration in a
  // deterministic way and record the `digest` without a `uri`. This allows one
  // to consider the client-side evaluation as a separate "build" with its own
  // provenance, such that the verifier can chain the two provenance
  // attestations together to determine the origin of the configuration.
  //
  // TODO: Some requirement that the builder verifies the URI and that the
  // verifier checks it against expectations?
  map<string, Artifact> inputArtifacts = 2;

  // Resolved dependencies needed at build time and referenced by
  // `inputArtifacts`, whether directly or transitively. For example, if the
  // build script fetches and executes "example.com/foo.sh", which in turn
  // fetches "example.com/bar.tar.gz", then both "foo.sh" and "bar.tar.gz"
  // should be listed here.
  //
  // The `inputArtifacts` SHOULD NOT be repeated here.
  //
  // TODO: Explain how to determine what goes here.
  // TODO: Explain that it's OK for it to be incomplete.
  // TODO: If the dep is already pinned, does it need to be listed here?
  repeated Artifact resolvedDependencies = 3;

  // The inputs to the build that are not artifacts.
  ParameterSet parameters = 4;
}

message Artifact {
  // TODO: Should we split out "locator" (ephemeral) from "identity" (static)?
  string uri = 1 [(subclass) = URI];
  DigestSet digest = 2;
  // TODO: add a "local name"?
  // TODO: add mediaType?
}

message DigestSet {
  string sha256 = 1;
  string sha512 = 2;
  // ...
}

message ParameterSet {
  // The identifier that determines the specific build definition within
  // `inputArtifacts`. This is often a path to a configuration file and optional
  // target label within that file. The syntax and interpretation are defined by
  // `type`.
  //
  // This field SHOULD be omitted if it is implicit from `type`. Being empty
  // simplifies verification of the provenance, thus is preferred when possible.
  //
  // Verifiers MUST compare this to an expected value.
  //
  // Design rationale: The `entryPoint` is distinct from `additionalParameters`
  // to make it easier to verify. Most builds need an entry point but not extra
  // parameters.
  string entryPoint = 1;

  // TODO: Enumeration to select between profiles, e.g. debug vs optimized. Is
  // this is a good idea?
  // TODO: Should this be a map<string,string> or just a repeated string?
  map<string, string> enums = 2;

  // TODO: We probably need os and architecture. How to record it? Anything else
  // in that category?

  // Additional per-invocation parameters that were not covered by another
  // field. The schema and interpretation are defined by `type`.
  //
  // TODO: finish explanation, particularly that consumers SHOULD have a way to
  // know what is expected, and thus it is simplest if it is empty
  google.protobuf.Struct additionalParameters = 3;
}

message RunDetails {
  // TODO: The following fields are the same as v0.2:
  Builder builder = 1;

  // TODO: description
  BuildMetadata metadata = 2;

  // Properties of the build environment that were provided by the `builder` and
  // not under user control. The primary intention of this field is for
  // debugging, incident response, and vulnerability management.
  //
  // The values here MAY be required for reproducing the build, but ideally this
  // would not be the case. For reproducibility, users should be instructed not
  // to rely on these values during the build.
  Environment environment = 5;

  // Additional artifacts generated during the build that should not be
  // considered the "output" of the build but that may be needed during
  // debugging or incident response.
  //
  // Possible use cases:
  //
  // -   Logs generated during the build.
  // -   Fully evaluated build configuration.
  //
  // In most cases, this SHOULD NOT contain all intermediate files generated
  // during the build. Instead, this should only contain files that are likely
  // to be useful later and that cannot be easily reproduced.
  repeated Artifact byproducts = 6;
}

message Builder {
  // TODO: In most cases this is implicit from the envelope layer (e.g. the
  // public key or x.509 certificate), which is just one more thing to mess up.
  // Can we rescope this to avoid the duplication and thus the security concern?
  // For example, if the envelope identifies the build system, this might
  // identify the tenant project?
  string id = 1 [(subclass) = URI];

  // TODO: Do we want to add this field? (#319)
  string version = 2;
}

message BuildMetadata {
  // TODO: same as v0.2:
  string invocationId = 1;
  google.protobuf.Timestamp startedOn = 2;
  google.protobuf.Timestamp finishedOn = 3;
}

message Environment {
  // Artifacts provided by the builder. The key is a name.
  map<string, Artifact> systemArtifacts = 1;
  // TODO: environment variables?
}
