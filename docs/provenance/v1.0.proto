syntax = "proto3";

package slsa.v1;

import "extensions.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// NOTE: We use lowerCamelCase for field names because that is how the JSON
// fields are named. The proto style guide advises use of snake_case in the
// .proto file but lowerCamelCase in JSON, but we believe that is confusing for
// readers (since we always serialize to JSON). It also makes it harder to
// reference other fields in comments since there are two ways to reference a
// field.

message Provenance {
  // The set of top-level inputs to the build. This SHOULD contain all the
  // information necessary and sufficient to:
  //
  // 1.  Run the build, provided understanding of the build type and access to
  //     all referenced input artifacts and dependencies.
  // 2.  Verify that the build was as expected.
  //
  // The build system should be designed to minimize the amount of information
  // necessary here, in order to reduce fragility and ease verification.
  // Consumers MUST have an expectation of what "good" looks like; the more
  // information that they must check, the harder that task becomes.
  //
  // Guidelines:
  //
  // -   Maximize the amount of information that is implicit from the meaning of
  //     `type`. In particular, any value that is boilerplate and the same for
  //     every build SHOULD be implicit.
  //
  // -   Avoid parameters by moving configuration to input artifacts whenever
  //     possible. For example, instead of passing in compiler flags via a
  //     parameter, require them to live next to the source code or build
  //     configuration.
  //
  // -   If possible, architect the build system to use this definition as its
  //     sole top-level input, in order to guarantee that the information is
  //     sufficient to run the build.
  //
  // -   Environment variables and artifacts that are not user controlled SHOULD
  //     be part of the `runDetails`, not here. For example, in GitHub Actions,
  //     a user can select which VM image but only from a set of pre-defined
  //     options; that enumeration may go here (though in practice it is part of
  //     the input artifact so it would not be recorded in the provenance) while
  //     the resolved VM version would go in `runDetails`.
  //
  // The accuracy and completeness of this information is implied by
  // `runDetails.builder.id`.
  BuildDefinition buildDefinition = 1;

  // Details about a specific execution of the build definition. Values here
  // MUST NOT be user controlled.
  RunDetails runDetails = 2;
}

message BuildDefinition {
  // URI indicating how to interpret and act upon this message.
  string type = 1 [(subclass) = "TypeURI"];

  // The top-level, independent input artifacts to the build. In many cases,
  // this is a singular "source" to be built.
  //
  // Each value MUST have a `category`. If there is only one entry, its
  // `category` SHOULD be "source".
  //
  // In some cases, the build configuration is evaluated client-side and sent
  // over the wire, such that the build system cannot determine its origin. In
  // those cases, the build system SHOULD serialize the configuration in a
  // deterministic way and record the `digest` without a `uri`. This allows one
  // to consider the client-side evaluation as a separate "build" with its own
  // provenance, such that the verifier can chain the two provenance
  // attestations together to determine the origin of the configuration.
  //
  // TODO: Some requirement that the builder verifies the URI and that the
  // verifier checks it against expectations?
  //
  // TODO: Idea from Shaun: should we have a tree heirarchy like lock files
  // rather than a flat list? Then perhaps we'd only need one field. The
  // "inputArtifacts" would be the top level of the hierarchy, and
  // `resolvedDependencies` would be all the lower levels. This would also allow
  // us to distinguish, if desired, between deps required by the build tool and
  // deps required by the source.
  repeated Artifact inputArtifacts = 2;

  // Resolved dependencies needed at build time and referenced by
  // `inputArtifacts`, whether directly or transitively. For example, if the
  // build script fetches and executes "example.com/foo.sh", which in turn
  // fetches "example.com/bar.tar.gz", then both "foo.sh" and "bar.tar.gz"
  // should be listed here.
  //
  // The `category` field is best effort and may be empty if unknown.
  //
  // The `inputArtifacts` SHOULD NOT be repeated here.
  //
  // TODO: Explain how to determine what goes here.
  // TODO: Explain that it's OK for it to be incomplete.
  // TODO: If the dep is already pinned, does it need to be listed here?
  repeated Artifact resolvedDependencies = 3;

  // The inputs to the build that are not artifacts.
  ParameterSet parameters = 4;
}

message Artifact {
  // How this artifact affects the build.
  //
  // category     | description
  // ------------ | -----------
  // `source`     | The primary input to the build.
  // `config`     | The build configuration, if different from `source`.
  // `builder`    | The top-level binary that runs the build.
  // `buildImage` | The container or VM image on which the build occurred.
  // `include`    | A dependency included in the output, such as a library.
  // `tool`       | A build dependency not included in the output, such as a compiler.
  //
  // TODO: What about dynamic linking / late binding?
  // TODO: Should we get rid of include vs tool since there's no way for the
  // builder to differentiate?
  // TODO: Offer more guidance on what these look like. For example, is
  // `builder` always expected?
  string category = 1 [(subclass) = "Enum"];

  // Collection of cryptographic digests for the contents of this artifact.
  DigestSet digest = 2;

  // The name for this artifact local to the build.
  //
  // Example: `PyYAML-6.0.tar.gz`
  string localName = 3;

  // The canonical identifier for this artifact, such as a Package URL or
  // version control URL. This value SHOULD be universal and stable, irrelevant
  // of the download or mirror location.
  //
  // Example: `pkg:pypi/pyyaml@6.0`
  string canonicalId = 4 [(subclass) = "URI"];

  // The location that this artifact was downloaded from, if not derivable from
  // `canonicalId`.
  //
  // Example: `https://files.pythonhosted.org/packages/36/2b/61d51a2c4f25ef062ae3f74576b01638bebad5e045f747ff12643df63844/PyYAML-6.0.tar.gz`
  string downloadLocation = 5 [(subclass) = "URI"];

  // The Media Type (aka MIME type) of this artifact.
  string mediaType = 6;
}

message DigestSet {
  string sha256 = 1;
  string sha512 = 2;
  // ...
}

message ParameterSet {
  // The identifier that determines the specific build definition within
  // `inputArtifacts`. This is often a path to a configuration file and optional
  // target label within that file. The syntax and interpretation are defined by
  // `type`.
  //
  // This field SHOULD be omitted if it is implicit from `type`. Being empty
  // simplifies verification of the provenance, thus is preferred when possible.
  //
  // Verifiers MUST compare this to an expected value.
  //
  // Design rationale: The `entryPoint` is distinct from `additionalParameters`
  // to make it easier to verify. Most builds need an entry point but not extra
  // parameters.
  string entryPoint = 1;

  // Note: the purpose of this is to make it easier to meet the "parameterless"
  // requirement by marking which parameters are "safe". But maybe it's not a
  // good idea...
  // TODO: Enumeration to select between profiles, e.g. debug vs optimized. Is
  // this is a good idea?
  // TODO: Should this be a map<string,string> or just a repeated string?
  map<string, string> enums = 2;

  // TODO: We probably need os and architecture. How to record it? Anything else
  // in that category?

  // Additional per-invocation parameters that were not covered by another
  // field. The schema and interpretation are defined by `type`.
  //
  // TODO: finish explanation, particularly that consumers SHOULD have a way to
  // know what is expected, and thus it is simplest if it is empty
  google.protobuf.Struct additionalParameters = 3;
}

message RunDetails {
  // TODO: The following fields are the same as v0.2:
  Builder builder = 1;

  // TODO: description
  BuildMetadata metadata = 2;

  // Properties of the build environment that were provided by the `builder` and
  // not under user control. The primary intention of this field is for
  // debugging, incident response, and vulnerability management.
  //
  // The values here MAY be required for reproducing the build, but ideally this
  // would not be the case. For reproducibility, users should be instructed not
  // to rely on these values during the build.
  //
  // TODO: Move to buildDefinition based on feedback from Shaun. It's weird that
  // it's here since it really is an input to the build. Need to figure out some
  // way to talk about "security boundaries".
  Environment environment = 5;

  // Additional artifacts generated during the build that should not be
  // considered the "output" of the build but that may be needed during
  // debugging or incident response.
  //
  // Possible use cases:
  //
  // -   Logs generated during the build.
  // -   Fully evaluated build configuration.
  //
  // In most cases, this SHOULD NOT contain all intermediate files generated
  // during the build. Instead, this should only contain files that are likely
  // to be useful later and that cannot be easily reproduced.
  repeated Artifact byproducts = 6;
}

message Builder {
  // TODO: In most cases this is implicit from the envelope layer (e.g. the
  // public key or x.509 certificate), which is just one more thing to mess up.
  // Can we rescope this to avoid the duplication and thus the security concern?
  // For example, if the envelope identifies the build system, this might
  // identify the tenant project?
  string id = 1 [(subclass) = "URI"];

  // TODO: Do we want to add this field? (#319)
  string version = 2;
}

message BuildMetadata {
  // TODO: same as v0.2:
  string invocationId = 1;
  google.protobuf.Timestamp startedOn = 2;
  google.protobuf.Timestamp finishedOn = 3;
}

message Environment {
  // Artifacts provided by the builder. The key is a name.
  repeated Artifact systemArtifacts = 1;
  // TODO: environment variables?
}
