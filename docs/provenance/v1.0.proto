syntax = "proto3";

package slsa.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// Design guidelines:
//
// -   Use lowerCamelCase for field names because that is how the JSON fields
//     are named. The proto style guide advises use of snake_case in the .proto
//     file but lowerCamelCase in JSON, but we believe that is confusing for
//     readers (since we always serialize to JSON). It also makes it harder to
//     reference other fields in comments since there are two ways to reference
//     a field.
//
// -   Prefer field names that are unique throughout the file, even if somewhat
//     redundant with the parent field. This makes it easier to reference in
//     documentation and reduces confusion.

message Provenance {
  // The input to the build.
  //
  // The accuracy and completeness of this information is implied by
  // `runDetails.builder.id`.
  BuildDefinition buildDefinition = 1;

  // Details specific to this particular execution of the build.
  RunDetails runDetails = 2;
}

message BuildDefinition {
  // The set of top-level inputs to the build. This SHOULD contain all the
  // information necessary and sufficient to:
  //
  // 1.  Run the build, provided understanding of the build type and access to
  //     all referenced input artifacts and dependencies.
  // 2.  Verify that the build was as expected.
  //
  // The build system should be designed to minimize the amount of information
  // necessary here, in order to reduce fragility and ease verification.
  // Consumers MUST have an expectation of what "good" looks like; the more
  // information that they must check, the harder that task becomes.
  //
  // Guidelines:
  //
  // -   Maximize the amount of information that is implicit from the meaning of
  //     `buildType`. In particular, any value that is boilerplate and the same
  //     for every build SHOULD be implicit.
  //
  // -   Avoid parameters by moving configuration to input artifacts whenever
  //     possible. For example, instead of passing in compiler flags via a
  //     parameter, require them to live next to the source code or build
  //     configuration.
  //
  // -   If possible, architect the build system to use this definition as its
  //     sole top-level input, in order to guarantee that the information is
  //     sufficient to run the build.
  BuildInputs topLevelInputs = 1;

  // Other information necessary to perform the build but either derived from
  // `topLevelInputs` or provided by the build system.
  //
  // The values here SHOULD NOT be under external control unless they are
  // constrained and unlikely to significantly affect the build. For example,
  // the username who triggered the build might be listed here, rather than
  // `topLevelInputs`, because it is a small input and unlikely to be affect the
  // behavior of the output, aside from simple inclusion.
  BuildDependencies buildDependencies = 2;
}

message BuildInputs {
  // [TypeURI] indicating how to interpret and act upon this message.
  //
  // TODO: Provide more guidance on how to define this.
  string buildType = 1;

  // The top-level, independent input artifacts to the build. In many cases,
  // this is a singular "source" to be built.
  //
  // The key is a name whose interpretation depends on `buildType`. If there is
  // only one input, it SHOULD be named "source". The following conventional
  // names are RECOMMENDED when appropriate:
  //
  // name            | description
  // --------------- | -----------
  // `source`        | The primary input to the build.
  // `config`        | The build configuration, if different from `source`.
  // `builderBinary` | The top-level binary that runs the build.
  // `buildImage`    | The container or VM image in which the build occurred.
  //
  // In some cases, the build configuration is evaluated client-side and sent
  // over the wire, such that the build system cannot determine its origin. In
  // those cases, the build system SHOULD serialize the configuration in a
  // deterministic way and record the `digest` without a `uri`. This allows one
  // to consider the client-side evaluation as a separate "build" with its own
  // provenance, such that the verifier can chain the two provenance
  // attestations together to determine the origin of the configuration.
  //
  // TODO: Some requirement that the builder verifies the URI and that the
  // verifier checks it against expectations?
  map<string, Artifact> inputArtifacts = 2;

  // The identifier that determines the specific build definition within
  // `inputArtifacts`. This is often a path to a configuration file and optional
  // target label within that file. The syntax and interpretation are defined by
  // `buildType`.
  //
  // This field SHOULD be omitted if it is implicit from `buildType`. Being
  // empty simplifies verification of the provenance, thus is preferred when
  // possible.
  //
  // Design rationale: The `entryPoint` is distinct from `parameters` to make it
  // easier to verify. Most builds need an entry point but not extra parameters.
  string entryPoint = 3;

  // TODO: We probably need os and architecture. How to record it? Anything else
  // in that category?

  // Additional per-invocation parameters that were not covered by another
  // field. The schema and interpretation are defined by `buildType`.
  //
  // TODO: finish explanation, particularly that consumers SHOULD have a way to
  // know what is expected, and thus it is simplest if it is empty
  google.protobuf.Struct parameters = 4;
}

message BuildDependencies {
  // Resolved dependencies needed at build time and referenced by
  // `buildDefinition`, whether directly or transitively. For example, if the
  // build script fetches and executes "example.com/foo.sh", which in turn
  // fetches "example.com/bar.tar.gz", then both "foo.sh" and "bar.tar.gz"
  // should be listed here.
  //
  // The `inputArtifacts` SHOULD NOT be repeated here.
  //
  // TODO: Explain what the purpose of this field is. Why do we need it?
  // TODO: Explain how to determine what goes here.
  // TODO: Explain that it's OK for it to be incomplete.
  // TODO: If the dep is already pinned, does it need to be listed here?
  // TODO: Should this be a map instead of an array? Then each MUST be named
  // explicitly, which would be less ambiguous but more difficult.
  repeated Artifact resolvedDependencies = 1;

  // Parameters of the build environment that were provided by the `builder` and
  // not under external control. The primary intention of this field is for
  // debugging, incident response, and vulnerability management. The values here
  // MAY be necessary for reproducing the build, but ideally this would not be
  // the case.
  google.protobuf.Struct environment = 2;
}

message Artifact {
  // [URI] describing where this artifact came from. When possible, this SHOULD
  // be a universal and stable identifier, such as a source location or Package
  // URL.
  //
  // Example: `pkg:pypi/pyyaml@6.0`
  string uri = 1;

  // Collection of cryptographic digests for the contents of this artifact.
  DigestSet digest = 2;

  // The name for this artifact local to the build.
  //
  // Example: `PyYAML-6.0.tar.gz`
  string localName = 3;

  // [URI] identifying the location that this artifact was downloaded from, if
  // different and not derivable from `canonicalId`.
  //
  // Example: `https://files.pythonhosted.org/packages/36/2b/61d51a2c4f25ef062ae3f74576b01638bebad5e045f747ff12643df63844/PyYAML-6.0.tar.gz`
  string downloadLocation = 4;

  // [Media Type] (aka MIME type) of this artifact.
  string mediaType = 5;
}

message DigestSet {
  string sha256 = 1;
  string sha512 = 2;
  // ...
}

message RunDetails {
  // TODO: The following fields are the same as v0.2:
  Builder builder = 1;

  // TODO: description
  BuildMetadata metadata = 2;

  // Additional artifacts generated during the build that should not be
  // considered the "output" of the build but that may be needed during
  // debugging or incident response.
  //
  // Possible use cases:
  //
  // -   Logs generated during the build.
  // -   Fully evaluated build configuration.
  //
  // In most cases, this SHOULD NOT contain all intermediate files generated
  // during the build. Instead, this should only contain files that are likely
  // to be useful later and that cannot be easily reproduced.
  //
  // TODO: Do we need some recommendation for how to distinguish between
  // byproducts? For example, should we recommend using `localName`?
  repeated Artifact byproducts = 3;
}

message Builder {
  // [URI] ... (same as v0.2)
  // TODO: In most cases this is implicit from the envelope layer (e.g. the
  // public key or x.509 certificate), which is just one more thing to mess up.
  // Can we rescope this to avoid the duplication and thus the security concern?
  // For example, if the envelope identifies the build system, this might
  // identify the tenant project?
  string id = 1;

  // TODO: Do we want to add this field? (#319)
  string version = 2;
}

message BuildMetadata {
  // TODO: same as v0.2:
  string invocationId = 1;
  google.protobuf.Timestamp startedOn = 2;
  google.protobuf.Timestamp finishedOn = 3;
}
